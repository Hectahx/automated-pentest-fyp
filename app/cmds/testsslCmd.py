import re
import asyncio
import requests
from requests.exceptions import ConnectionError, Timeout, SSLError,RequestException

def is_website_online(url, cookies=None):
    try:
        # If cookies are provided, they are sent with the request
        response = requests.head(url, timeout=5, cookies=cookies)
        return response.status_code == 200
    except RequestException:
        # Handles all exceptions that might occur during the request
        return False

def is_https(url):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'
    }
    
    try:
        # Ensure URL starts with https://
        if not url.startswith('https://'):
            url = 'https://' + url.lstrip('http://')

        # Use a session for connection pooling
        with requests.Session() as session:
            session.headers.update(headers)
            
            # Prevent automatic redirections
            response = session.get(url, timeout=5, allow_redirects=False)
            
            # Check if the status code is for redirection
            if response.status_code in (301, 302, 307, 308):
                # Follow the redirect manually and check the scheme
                redirect_url = response.headers['Location']
                if not redirect_url.startswith('https://'):
                    return [False, "This site is HTTP"]
                # Recursively check the redirect URL
                return is_https(redirect_url)

            return [response.url.startswith('https://'), "True"]

    except (ConnectionError, SSLError) as e:
        #print(f"SSL or connection error occurred: {e}")
        return [False, "An SSL Error Occured - This site is most likely HTTP"]
    except Timeout:
        #print("The request timed out")
        return [False, "The request timed out"]
    except Exception as e:
        #print(f"An error occurred: {e}")
        return [False, f"An error occurred: {e}"]


def remove_ansi_escape_codes(text):
    ansi_escape_regex = re.compile(r'\x1b\[([0-9A-Za-z;?]*[mK])')
    regexText =  ansi_escape_regex.sub('', text)
    return regexText.replace("\\n", "\n")

def format_results(output:str):
    all_protocols_str = output.split("Testing protocols via sockets except NPN+ALPN")[1].split("Testing vulnerabilities")[0].strip()
    all_vulnerabilities_str = output.split("Testing protocols via sockets except NPN+ALPN")[1].split("Testing vulnerabilities")[1].split("Done")[0].strip()

    all_protocols = {}
    all_vulns = {}

    #Dictionary of bad protocols/vulns
    bad_dict = {
        "is_bad_protocols" : False,
        "is_bad_vulns" : False,
        "bad_vulns" : {},
        "bad_protocols" : {}
    }

    protocol_array = all_protocols_str.split("\n")
    vuln_array  = [x.strip() for x in all_vulnerabilities_str.split("\n") if x.strip()]

    #Formatting Protocols into a dictionary of into this format {"PROTOCOL": "RESULT"}
    for line in protocol_array:
        try:
            parts = line.split(maxsplit=1)
            if len(parts) == 2:
                # Extracting protocol and result
                protocol = parts[0].strip()
                result = parts[1].strip()

                # Special handling for TLS versions
                if 'TLS' in protocol:
                    protocol_parts = line.split(maxsplit=2)
                    protocol = ' '.join(protocol_parts[:2])
                    result = protocol_parts[2].strip()

                all_protocols[protocol] = result
        except IndexError:
                continue

    #print(all_protocols)
            
    for line in vuln_array:
        try:
            parts = line.split(maxsplit=1)
            vuln = parts[0].strip()
            result = parts[1].strip()
            all_vulns[vuln] = result
        except IndexError:
            continue

    bad_vulns = {vuln: result for vuln, result in all_vulns.items() if "(OK)" not in result}
    bad_protocols = {protocol: result for protocol, result in all_protocols.items() if "(OK)" not in result}
    
    bad_vulns.pop("but", None)

    bad_protocols.pop("ALPN/HTTP2", None)
    bad_protocols.pop("NPN/SPDY", None)
    
    if len(bad_vulns):
        bad_dict["is_bad_vulns"] = True

    if len(bad_protocols):
        bad_dict["is_bad_protocols"] = True
    
    bad_dict["bad_protocols"] = bad_protocols
    bad_dict["bad_vulns"] = bad_vulns
    
    #print(all_vulns)
    #print(vuln_array)

    return bad_dict



async def run_testssl(url: str, login=False):
    # Define the command and parameters as a list
    command = [
        './testssl/testssl.sh',
        '-p',
        '-H',
        '-I',
        '-T',
        '-BB',
        '-R',
        '-O',
        '-Z',
        '-J',
        '-4',
        url
    ]
    if is_website_online(url) is False:
        bad_dict = {
            "is_bad_protocols" : None,
            "is_bad_vulns" : None,
            "bad_vulns" : {},
            "bad_protocols" : {},
            "error" : True,
            "error_message" : "Invalid URL"
        }
        return bad_dict
    
    https_result = is_https(url)
    if(https_result[0] == False):
        bad_dict = {
            "is_bad_protocols" : True,
            "is_bad_vulns" : False,
            "bad_vulns" : {},
            "bad_protocols" : {
                "HTTP" : "This website uses HTTP instead of HTTPs"
            }

        }
        return bad_dict

    # Run the command
    process = await asyncio.create_subprocess_exec(
        *command,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )

    # Wait for the command to complete and get the output
    stdout, stderr = await process.communicate()

    # The stdout and stderr are bytes, decode to string
    stdout_output = stdout.decode()
    stderr_output = stderr.decode()
    #print(stdout_output)


   
    if process.returncode == 0:
        print("testssl executed successfully.")
        formatted_output = remove_ansi_escape_codes(stdout_output)
        
        return format_results(formatted_output)
    else:
        print("Command failed - TestSSL")
        return [None, "Command failed"]
        #return None
    
async def main():
    # Run sqlmap and get the output
    #testssl_output = await run_testssl("https://tls-v1-0.badssl.com:1010/")
    testssl_output = await run_testssl("https://tls13.1d.pw/")
    #testssl_output = await run_testssl("http://192.168.124.132/login/")
    if testssl_output is not None:
        # Use sqlmap_output for something else
        #print(testssl_output)
        print(testssl_output)

if __name__ == '__main__':
    asyncio.run(main())
