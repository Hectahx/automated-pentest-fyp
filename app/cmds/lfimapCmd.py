import asyncio
import re
from collections import defaultdict
import requests
from requests.exceptions import RequestException


def is_website_online(url, cookies=None):
    try:
        # If cookies are provided, they are sent with the request
        response = requests.head(url, timeout=5, cookies=cookies)
        return response.status_code == 200
    except RequestException:
        # Handles all exceptions that might occur during the request
        return False
    
async def run_lfimap(url, cookie=None, login=False):
    try:
        result = {
            "url": url,
            "is_vulnerable" : None,
            "vulns_found" : None,
            "error" : False,
            "error_message" : None
        }
        # Construct the command to run lfimap.py
        command = [
            'python3', 
            '-u', #Unbuffered mode - allows the command to be read into stdout
            './lfimap/lfimap.py',
            '-U', url,
            '-v',  # Verbose mode
            '-a'
        ]

        if not is_website_online(url, cookies=cookie):
            print(f"Page does not exist - lfimap")
            result["is_vulnerable"] = None
            result["error"] = True
            result["error_message"] = "invalid URL"
            return result


        if cookie != None:
            command.extend(["-C", cookie])

            # Run the command
        process = await asyncio.create_subprocess_exec(
            *command,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )

        # Wait for the command to complete and get the output
        stdout, stderr = await process.communicate()

        # The stdout and stderr are bytes, decode to string
        stdout_output = stdout.decode()
        stderr_output = stderr.decode()
        #print(stdout_output)

        # You can process the output further here
        if process.returncode == 0:
            #print("Command executed successfully.")
            vulns = extract_vulnerabilities(stdout_output)
            #print(stdout_output)
            result["is_vulnerable"] = vulns[0]
            #result["vulns_found"] = vulns[1]
            vuln_techniques = extract_vulnerability_techniques(stdout_output)
            result["vulns_found"] =  {
                "num_vulns" : vulns[1],
                "vuln_techniques" : vuln_techniques
            }
            return result # Adds the URL to the end of the array returned by this function - shows what pages are vulnerable
        else:
            #print("Command failed.")
            #print(stderr_output)
            result["is_vulnerable"] = None
            result["error"] = True
            result["error_message"] = stdout_output
            return result
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        result["is_vulnerable"] = None
        result["error"] = True
        result["error_message"] = e
        return result
    

def extract_vulnerabilities(output):
    #Returns the number of vulnerabilities found, or None if not found.
    match = re.search(r"Vulnerabilities found:\s+(\d+)", output)
    
    if not match:
        return None

    if int(match.group(1)) > 0:
        return [True, f"Number of vulnerabilities found: {int(match.group(1))}"]
    else:
        return [False, f"Number of vulnerabilities found: {int(match.group(1))}"]

def extract_vulnerability_techniques(output):
    """
    Extracts URLs and the LFI techniques they are vulnerable to from the provided output text.

    :param output: str, output from the vulnerability scanning tool.
    :return: dict, mapping of URLs to the list of LFI techniques they are vulnerable to.
    """
    vulnerabilities = {}
    # Patterns to look for that indicate the testing of a specific technique
    technique_indicators = {
        "filter wrapper": "Testing with filter wrapper...",
        "input wrapper": "Testing with input wrapper...",
        "data wrapper": "Testing with data wrapper...",
        "expect wrapper": "Testing with expect wrapper...",
        "file wrapper": "Testing with file wrapper...",
        "remote file inclusion": "Testing remote file inclusion...",
        "path truncation": "Testing path truncation using",
        "OS command injection": "Testing results-based OS command injection..."
    }
    current_technique = None

    for line in output.split('\n'):
        # Determine the current technique being tested
        for technique, indicator in technique_indicators.items():
            if indicator in line:
                current_technique = technique
                break
        
        # Check if the line indicates a found vulnerability
        if '[+]' in line and 'LFI ->' in line:
            # Extract the URL from the line
            url = line.split('\'')[1]
            if url not in vulnerabilities:
                vulnerabilities[url] = current_technique
            elif current_technique not in vulnerabilities[url]:
                vulnerabilities[url].append(current_technique)

    return vulnerabilities
    
async def main():
    url = "http://192.168.124.132/login/user.php?page=view_profile.php"
    cookie = "PHPSESSID=cth189e908h9lar49cbpi45scb"
    # Run sqlmap and get the output
    lfimap_output = await run_lfimap(url,cookie)
    if lfimap_output is not None:
        # Use sqlmap_output for something else
        print(lfimap_output)

if __name__ == '__main__':
    asyncio.run(main())
