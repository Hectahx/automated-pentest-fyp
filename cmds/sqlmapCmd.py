import asyncio
import re

async def run_sqlmap(url: str, login=False):
    try:
        result = {
            "url": url,
            "is_vulnerable" : None,
            "vulns_found" : None,
            "error" : False,
            "error_message" : None
        }
        # Define the command and parameters as a list
        command = [
            'sqlmap',
            #'-u', '192.168.124.128/login_secured/login.php',
            '-u', url,
            #'--data', 'username=test@test.com&password=test',
            #'--forms',
            '--level', '5',
            '--risk', '3',
            '-f',
            '--banner',
            '--ignore-code', '401',
            '--flush-session',
            '--batch'
        ]

        sql_url_pattern = re.compile(r'https?:\/\/[\w.-]+(?:\.[\w.-]+)+[\w\-\._~:/?#\[\]@!$&\'()*+,;=]*(\?|&)([\w.-]+=[\w.-]+)')

        if re.search(sql_url_pattern, url) == None:
            command.append("--forms")

        # Run the command
        process = await asyncio.create_subprocess_exec(
            *command,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )

        # Wait for the command to complete and get the output
        stdout, stderr = await process.communicate()

        # The stdout and stderr are bytes, decode to string
        stdout_output = stdout.decode()
        stderr_output = stderr.decode()


        # You can process the output further here
        if process.returncode == 0:
            print("sqlmap executed successfully.")
            sql_injection_found =  check_sql_injection_found(stdout_output)
            result["is_vulnerable"] = sql_injection_found[0]
            result["vulns_found"] = sql_injection_found[1]
            return result
        else:
            #print("Command failed.")
            result["is_vulnerable"] = None
            result["error"] = True
            result["error_message"] = stdout_output
            return result
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        result["is_vulnerable"] = None
        result["error"] = True
        result["error_message"] = e
        return result
    
    
def check_sql_injection_found(stdout_output: str):
    ## Returns True if the specific phrase is found, False otherwise.
    search_phrase = "sqlmap identified the following injection point"
    if search_phrase in stdout_output:
        payloads = stdout_output.split("\n---\n")
        return [True, format_sqlmap_output(payloads[1])]
    else:
        return [False, stdout_output]

def format_sqlmap_output(block_text):
    # Extract parameter and method
    param_method_pattern = r"Parameter: (\w+) \((\w+)\)"
    param_method_match = re.search(param_method_pattern, block_text)
    parameter, method = param_method_match.groups() if param_method_match else ("", "")

    # Initialize the result dictionary
    result = {
        "parameter": parameter,
        "method": method,
        "sqli_types": []
    }

    # Adjusted pattern to handle indented multiline sections
    sqli_pattern = r"Type: (.*?)\n\s*Title: (.*?)\n\s*Payload: (.*?)\n(?=\n|\Z)"
    
    # Using DOTALL flag to make '.' match newline characters as well
    sqli_matches = re.findall(sqli_pattern, block_text, re.DOTALL)

    for sqli_match in sqli_matches:
        sqli_type, title, payload = [x.strip() for x in sqli_match]
        result["sqli_types"].append({
            "type": sqli_type,
            "title": title,
            "payload": payload
        })

    return result


async def main():
    # Run sqlmap and get the output
    sqlmap_output = await run_sqlmap()
    if sqlmap_output is not None:
        # Use sqlmap_output for something else
        print(sqlmap_output)

if __name__ == '__main__':
    asyncio.run(main())
