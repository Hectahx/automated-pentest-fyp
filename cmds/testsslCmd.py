import asyncio
import re

def remove_ansi_escape_codes(text):
    ansi_escape_regex = re.compile(r'\x1b\[([0-9A-Za-z;?]*[mK])')
    regexText =  ansi_escape_regex.sub('', text)
    return regexText.replace("\\n", "\n")

def format_results(output:str):
    all_protocols_str = output.split("Testing protocols via sockets except NPN+ALPN")[1].split("Testing vulnerabilities")[0].strip()
    all_vulnerabilities_str = output.split("Testing protocols via sockets except NPN+ALPN")[1].split("Testing vulnerabilities")[1].split("Done")[0].strip()

    all_protocols = {}
    all_vulns = {}

    #Dictionary of bad protocols/vulns
    bad_dict = {
        "is_bad_protocols" : False,
        "is_bad_vulns" : False,
        "bad_vulns" : {},
        "bad_protocols" : {}
    }

    protocol_array = all_protocols_str.split("\n")
    vuln_array  = [x.strip() for x in all_vulnerabilities_str.split("\n") if x.strip()]

    #Formatting Protocols into a dictionary of into this format {"PROTOCOL": "RESULT"}
    for line in protocol_array:
        try:
            parts = line.split(maxsplit=1)
            if len(parts) == 2:
                # Extracting protocol and result
                protocol = parts[0].strip()
                result = parts[1].strip()

                # Special handling for TLS versions
                if 'TLS' in protocol:
                    protocol_parts = line.split(maxsplit=2)
                    protocol = ' '.join(protocol_parts[:2])
                    result = protocol_parts[2].strip()

                all_protocols[protocol] = result
        except IndexError:
                continue

    #print(all_protocols)
            
    for line in vuln_array:
        try:
            parts = line.split(maxsplit=1)
            vuln = parts[0].strip()
            result = parts[1].strip()
            all_vulns[vuln] = result
        except IndexError:
            continue

    bad_vulns = {vuln: result for vuln, result in all_vulns.items() if "(OK)" not in result}
    bad_protocols = {protocol: result for protocol, result in all_protocols.items() if "(OK)" not in result}
    
    bad_vulns.pop("but", None)

    bad_protocols.pop("ALPN/HTTP2", None)
    bad_protocols.pop("NPN/SPDY", None)
    
    if len(bad_vulns):
        bad_dict["is_bad_vulns"] = True

    if len(bad_protocols):
        bad_dict["is_bad_protocols"] = True
    
    bad_dict["bad_protocols"] = bad_protocols
    bad_dict["bad_vulns"] = bad_vulns
    
    #print(all_vulns)
    #print(vuln_array)

    return bad_dict



async def run_testssl(url: str, login=False):
    # Define the command and parameters as a list
    command = [
        './testssl/testssl.sh',
        '-p',
        '-H',
        '-I',
        '-T',
        '-BB',
        '-R',
        '-O',
        '-Z',
        '-J',
        '-L',
        '-4',
        url
    ]

    # Run the command
    process = await asyncio.create_subprocess_exec(
        *command,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )

    # Wait for the command to complete and get the output
    stdout, stderr = await process.communicate()

    # The stdout and stderr are bytes, decode to string
    stdout_output = stdout.decode()
    stderr_output = stderr.decode()
    #print(stdout_output)


    # You can process the output further here
    if process.returncode == 0:
        print("testssl executed successfully.")
        formatted_output = remove_ansi_escape_codes(stdout_output)
        
        return format_results(formatted_output)
    else:
        #print("Command failed.")
        return [None, "Command failed"]
        #return None
    
async def main():
    # Run sqlmap and get the output
    #testssl_output = await run_testssl("https://tls-v1-0.badssl.com:1010/")
    testssl_output = await run_testssl("https://tls-v1-2.badssl.com:1012/")
    if testssl_output is not None:
        # Use sqlmap_output for something else
        #print(testssl_output)
        print(testssl_output)

if __name__ == '__main__':
    asyncio.run(main())
